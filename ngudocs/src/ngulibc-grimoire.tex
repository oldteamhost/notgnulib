\documentclass[12pt, letterpaper]{article}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english, russian]{babel}

\usepackage{multirow}
\usepackage{fancyhdr}
\usepackage{colortbl}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{float}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{tocloft}
\usepackage{titletoc}
\usepackage{graphicx}

\title{C LIBRARY GRIMOIRE}
\author{lomaster \& oldteam}

\lstset
{
  language=C++,
  basicstyle=\ttfamily\small,
  numbers=left,
  numberstyle=\tiny\color{gray},
  frame=single,
  escapeinside={(*@}{@*)},
  breaklines=true
}

\date{2023}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage

\section{Введение}
Я все таки решился написать руководство по всей стандартной библиотеки C, но, прежде чем перейти к нему нужно понять что это вообще такое, и как же все начиналось.

А началось все в 1972 году, когда создатель Cи (Dennis Ritchie), вместе с самим C, выкатывает и стандартную библиотеку для него.
Сама библиотека, котороя состояла из довольно маленького набора функций, которые были прописаны еще и в самом компиляторе, уже содержала в себе функции для: Ввода-вывода,
работы со строками, символами, математикой, и файлами. Также по casual UNIX традиции, открывать код компиляторов нельзя, поэтому мы так и не сможем увидеть код первой библиотеки,
хотя наверно и к лучшему.

Дальше по лору в игру вступили ANSI C, которые в 1989 году выкатывают стандарт по стандартной библиотеки Си. И Международная организация по стандартам его спокойно подтверждает.
Но они были не одни, попутно с ними работали и POSIX, которые хреначили уже свою спецификацию для стандартной библиотеки Си.

По итогу в наше время все сложилось так, что ANSI C задал самую базу, вроде имен заголовочных файлов, основных функций и другого, а POSIX разширил эту базу. Вообще я тут упустил довольно много,
потому что стандарты Си выходят до сих пор, но это будет слишком долго и не особо интересно, тем более их до сих пор делают ANSI C и POSIX, вообщем главное я тут сказал.

\subsection{Важные дополнения}
Это руководство не по языку Си, а по последнему стандарту стандартной библиотеки, это (C11), и оно не привязано конкретно к ngulibc,
тут будет и POSIX стандарт.

\section{assert.h}
<\textbf{assert.h}> - определяет макрос функцию \textbf{assert}, которую используют для проверки ошибок
путем условия, например:
\begin{lstlisting}
assert(size == 100);
\end{lstlisting}
Сам макрос определен на основе другой функции:
\begin{lstlisting}
#define assert(e) \
((e) ? (void)0 : __assert(__func__, __FILE__, __LINE__, #e))
\end{lstlisting}
Может показатся сложным, но это совсем не так. Вот сама функция на которой он основан:
\begin{lstlisting}
void
__assert(const char* func, const char* file, int line, const char* expression);
\end{lstlisting}
Все ее аргументы указывают местоположение вызова функции \textbf{assert}, которая вернула \textbf{false}.
Первый ее аргумент это функция, второй файл,
третий строчка, и четвертый это выражение которое вызвало ошибку, \textbf{aka} условие которое вернуло \textbf{false}.
\newline
\newline
Макрос тут нужен просто для упрощения использования этой функции, ведь пользователю будет просто лень, указывать файл, строчку, и т.д.
\newline
\newline
Давайте разберем макрос: \textbf{(e)} - это условие которое указывает пользователь, например: \textbf{10 == 9}.
Затем с помощью тернарного оператора, идет проверка статуса этого условия, другими словами проверка, оно \textbf{true} или \textbf{flase}.
Если оно \textbf{true}, тогда макрос просто ничего не делает, указание \textbf{(void)0} нужно только для компилятора, что бы он не выдавал
предупреждения.
Если же условие \textbf{false} тогда идет вызов функции \textbf{assert} которую мы до этого разбирали, вот как выглядит вызов:
\begin{lstlisting}
__assert(__func__, __FILE__, __LINE__, #e))
\end{lstlisting}
Макрос \textbf{func} определяет компилятор, это название функции в которой находится вызов этого макроса,
соответственно и вызов \textbf{assert}, со всеми остальными макросами это: \textbf{FILE}, \textbf{LINE}, аналогично.
Можно и по названию догадаться.
\newline
\newline
Что за \textbf{хэштег e}? Если вы не знали то с помощью \textbf{хэштега}
в макросах, можно застаить компилятор превратить аргумент этого макроса, в тип данных \textbf{string}.
\newline
\newline
Было:
\begin{lstlisting}
#define (e) e
/*
 * result: 10 == 9
*/
\end{lstlisting}
Стало:
\begin{lstlisting}
#define (e) # e
/*
 * result: "10 == 9"
*/
\end{lstlisting}
PS: Он просто взял значение аргумента \textbf{e} в кавычки.

\subsection{Как использовать функцию assert()}
В данном примере ничего не произойдет, потому что \textbf{10} действительно равно \textbf{10}-ти:
\begin{lstlisting}
/* main.c */
int main(void)
{
  assert(10 == 10); /* return true */
}
\end{lstlisting}
Вот другой пример в котором все иначе:
\begin{lstlisting}
/* main.c */
int main(void)
{
  assert(10 == 9); /* pipec */
}
\end{lstlisting}
В этом случае условие вернет \textbf{false}, поэтому ваша программа сразу же завершится, и в консоль вы получите такой вывод:
\newline
\newline
\textbf{Assertion failed: (10 == 9), function main, file main.c, line 4.}
\newline
\newline
Тут показано: само условие, функция, файл, и строчка, которая и вызывала эту ошибку.
Этот текст функция запишет в поток \textbf{stderr}, это поток для ошибок.
\newline
\newline
PS: Программа завершается с кодом (\textbf{1})
\newline
\newline
Также если функция \textbf{assert} вернула \textbf{false}, но это было не в функции, то вывод будет таким:
\textbf{Assertion failed: (10 == 9), file main.c, line 4.}
\subsection{Особенность заголовка assert.h}
Особенность это макрос \textbf{NDEBUG}, определив который, перед включением <\textbf{assert.h}>, вы можете сделать так что бы
все функции \textbf{assert} в вашем файле, просто пропускались, если точнее то всегда были \textbf{(void)0}.
\begin{lstlisting}
/* main.c */
#define NDEBUG
#include <assert.h>

int main(void)
{
  assert(10 == 9);
}
\end{lstlisting}
Таким образом, несмотря на то что условие вернуло \textbf{false}, функция \textbf{assert} просто ничего не будет делать.

\section{iso646.h}
<\textbf{iso646.h}> - определяет \textbf{11} макросов для высокоуровневой замены побитовых и логических операторов.
Был добавлен в стандарте \textbf{C90} в \textbf{1995} году, скорее всего \textbf{1} апреля).
\begin{lstlisting}
#define and     &&
#define and_eq  &=
#define bitand  &
#define bitor   |
#define compl   ~
#define not     !
#define not_eq  !=
#define or      ||
#define or_eq   |=
#define xor     ^
#define xor_eq  ^=
\end{lstlisting}
Это и есть все его макросы, думаю объяснять не нужно.

\subsection{Зачем это надо}
На самом деле у этого действительно был смысл, дело в том что раньше \textbf{QWERTY}-клавиатуры (как у нас сейчас), были не у всех.
И расположение таких символов было просто адским, на некоторых клавиатурах. И легче было написать \textbf{and}, чем тянуть руку
на метр до сраного амперсанда.

\section{stdlib.h}
<\textbf{stdlib.h}> - расшифровывается как "standard library".
И содержит в себе функции для преобразованием типов, выделения памяти, генерации рандомных чисел, сортировки, поиска,
матемитики, и контроля процесса выполнения программы.
\newline
\newline
Давайте вначале разберем макросы и новые типы данных, которые он определяет:
\begin{lstlisting}
#define NULL ((void *) 0)
\end{lstlisting}
Это тот самый \textbf{NULL}, но такое определение он имеет именно в \textbf{C}, в C++ же его опредление выглядет иначе:
\begin{lstlisting}
#define NULL nullptr
\end{lstlisting}
Но есть еще одно определение, которое работает только при компиляции через \textbf{gcc}:
\begin{lstlisting}
#define NULL __null
\end{lstlisting}
В данном случае \textbf{gcc} определяет свой \textbf{NULL}.
\newline
\newline
Дальше идет определение нового типа данных, это \textbf{size t}, который используется для представления размера объекта.
Также заметьте что его определение условное на основе макроса \textbf{WORDSIZE}, это размер машинного слова, \textbf{aka}, разрядность процессора.

\begin{lstlisting}
#if __WORDSIZE == 64
  typedef ___uint64_t ___size_t;
#else
  typedef ___uint32_t ___size_t;
#endif
\end{lstlisting}

Но <\textbf{stdlib.h}> определяет еще \textbf{2} типа данных, это \textbf{div t} и \textbf{ldiv t}, которые используется только для
функций \textbf{div} и \textbf{ldiv}, как их возвращаемое значение.

\begin{lstlisting}
typedef struct
{
  int quot, rem;
} div_t;

typedef struct
{
  long int quot, rem;
} ldiv_t;
\end{lstlisting}

\subsection{Функции преобразование типов}
Большинство функций тут начинаются с <<\textbf{ato}>>, это название происходит от <<\textbf{ASCII to}>> на русском (ASCII в).
Другие же начинаются с <<\textbf{strt}>>, это происходит от <<\textbf{string to}>> на русском (строка в).
\newline
\newline
\textbf{atof} - преобразование строки в \textbf{double}(число двойной точности), обратите внимание что для \textbf{float} она не подходит! \textit{(C89, C89)}.
\newline
\newline
\textbf{atoi} - одна из самых популярных функций, преобразование строки в \textbf{int}(целое число) \textit{(C89, C99)}.
\newline
\newline
\textbf{atol} - преобразование строки в \textbf{long int}(длинное целое число) \textit{(C89, C99)}.
\newline
\newline
\textbf{atoll} - преобразование строки в \textbf{long long int}(еще более длинное целое число) \textit{(C99)}.
\newline
\newline
\textbf{strtod} - преобразование строки в \textbf{double}, аналог \textbf{atof}, но предоставляет более подробную информацию об ошибке, в случае таковой \textit{(C89, C89)}.
\newline
\newline
\textbf{strtof} - преобразование строки в \textbf{float}(число одиночной точности) \textit{(C99)}.
\newline
\newline
\textbf{strtol} - преобразование строки в \textbf{long int}, также как и с \textbf{strtod} аналогична другой функции (\textbf{atol}), и отличается от таковой также более подробному учету ошибок \textit{(C89, C99)}.
\newline
\newline
\textbf{strtold} - преобразование строки в \textbf{long double}(длинное число двойной точности) \textit{(C99)}.
\newline
\newline
\textbf{strtoll} - преобразование строки в \textbf{long long int}, ситуация такая же как и с \textbf{strtol} и \textbf{strtod} \textit{(C99)}.
\newline
\newline
\textbf{strtoul} - преобразование строки в \textbf{unsigned long int}(беззнаковое длинное целое число) \textit{(C89, C99)}.
\newline
\newline
\textbf{strtoull} - преобразование строки в \textbf{unsigned long long int}(беззнаковое еще более длинное целое число) \textit{(C99)}.

\subsection{Функции генерация псевдослучайных значений}
\textbf{rand} - генерирует псевдослучайное значение, основана на функции \textbf{randomr}, которая в большинстве библиотек \textbf{C},
использует алгоритм \textbf{LCG} (\textbf{Linear Congruential Generator}) для генерации \textit{(C89, C99)}.
\newline
\newline
\textbf{srand} - устанавливает начальное значение(\textbf{seed}) для генератора псевдослучайных чисел \textit{(C89, C99)}.

\subsection{Функции для работы с памятью}
\textbf{malloc}(Memory Allocation) - одна из самых популярных функций во всей библиотеки, используется для выделения блока памяти
заданного размера в куче (от англ. heap), куча это область памяти, доступная для динамического выделения и освобождения \textit{(C89, C99)}.
\newline
\newline
Примечание: Память, выделенная с помощью \textbf{malloc}, не инициализируется, и её содержимое остаётся неопределенным.
\newline
\newline
\textbf{calloc}(Contiguous Allocation) - также используется для выделения блока памяти в куче,
но в отличие от \textbf{malloc}, она инициализирует всю выделенную память нулями. Это особенно полезно при работе
с массивами или структурами, где необходимо гарантировать, что все элементы инициализированы \textit{(C89, C99)}.
\newline
\newline
\textbf{realloc}(Reallocate Memory) - используется для изменения размера ранее выделенного блока памяти.
Она принимает указатель на существующий блок памяти, новый размер, и, если возможно, перемещает данные в новый блок памяти указанного размера \textit{(C89, C99)}.
\newline
\newline
Примечание: Оригинальный блок памяти освобождается.
\newline
\newline
\textbf{free}(Free Allocated Memory) - используется для освобождения выделенной в куче памяти.
Освобождение памяти позволяет системе операционной системы переиспользовать этот участок памяти
для других целей. После вызова \textbf{free}, указатель на эту память становится недействительным, и он больше
не должен использоваться. Не освобожденная память может привести к утечкам памяти, что может вызвать проблемы в работе программы
\textit{(C89, C99)}.

\subsection{Функции для контроля выполнения программы}
Большинство функций здесь это системные вызовы, и написаны на \textbf{assembler-е}.
\newline
\newline
\textbf{abort} - используется для завершения программы с кодом ответа \textbf{SIGABRT} (6), применяется именно для завершения программы в случае ошибки.
\newline
\newline
\textbf{atexit} - как по мне это довльно по философски, используется для регистрации функции, которая будет вызвана перед завершением программы.
Она не завершает программу сразу, а лишь указывает функцию которая будет выполнена перед завершение программы.
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

void goodbye(void)
{
  printf("goodbye\n");
}

int main()
{
    atexit(goodbye);
    printf("Hello, world!\n");
    printf("Hello, world!\n");
    printf("Hello, world!\n");

    return 0;
}
\end{lstlisting}
Функции \textbf{goodbye} будет вызвана именно на \textbf{return 0}.


\section{float.h}
<\textbf{float.h}> - определяет макросы для ограничения параметров и типов данных с плавающей точкой.
Вообщем просто аналог \textbf{limits.h}, но для типов данных \textbf{float} и \textbf{double}. \textit{(C89, C89)}.

\section{stdbool.h}
<\textbf{stdbool.h}> - определяет \textbf{4} макроса для работы с типом данных \textbf{bool}.
Почему для работы с ним? Потому что cам тип данных \textbf{bool} определяет компилятор, ввиде такого макроса:
\begin{lstlisting}
_Bool
\end{lstlisting}
Поэтому в файле \textbf{stdbool.h} тип данных \textbf{bool} определяется вот так:
\begin{lstlisting}
#define bool _Bool
\end{lstlisting}
Затем идет определение двух значений для него:
\begin{lstlisting}
#define true   1
#define false  0
\end{lstlisting}
Под конец файла, определяется макрос, который указывает что тип данных \textbf{bool} определен:
\begin{lstlisting}
#ifndef __bool_true_false_are_defined
  #define __bool_true_false_are_defined  1
#endif
\end{lstlisting}

\section{limits.h}
<\textbf{limits.h}> - определяет макросы для ограничения целочисленных типов данных.
Причем стоит учитывать, что размеры типов данных семейства \textbf{long}, завясят от разрядности процессора.
Разрядность определяется с помощью константы \textbf{WORDSIZE}, если она равна \textbf{64}, то процессор \textbf{64-х} битный.
\end{document}
